<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>装载</title>
      <link href="/2019/08/04/%E8%A3%85%E8%BD%BD/"/>
      <url>/2019/08/04/%E8%A3%85%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="一、进程虚拟地址空间"><a href="#一、进程虚拟地址空间" class="headerlink" title="一、进程虚拟地址空间"></a>一、进程虚拟地址空间</h3><h4 id="PAE-Physical-Address-Extension"><a href="#PAE-Physical-Address-Extension" class="headerlink" title="PAE(Physical Address Extension)"></a>PAE(Physical Address Extension)</h4><ul><li>32位的CPU下，程序能使用的空间能不能超过4GB呢？  </li></ul><p>1.如果指的是虚拟地址空间，是不能访问超过4G的，因为32位读cpu只能使用32的指针。<br>2.Intel自从1995年读PentiumPro CPU开始采用了36位的物理地址，可以访问64GB的物理内存。  </p><ul><li>应用程序如何使用这些大于常规的内存空间呢？  </li></ul><p>1.window：AWE(Address Windowing Extension)<br>2.linux:mmap()系统调用  </p><h3 id="二、装载的方式"><a href="#二、装载的方式" class="headerlink" title="二、装载的方式"></a>二、装载的方式</h3><p>2.1 覆盖装入(Overlay)<br>2.2 页映射(Paging)  </p><h3 id="三、进程的建立"><a href="#三、进程的建立" class="headerlink" title="三、进程的建立"></a>三、进程的建立</h3><p>3.1 创建虚拟地址空间<br>3.2 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。<br>进程虚拟空间中的一个段：<br> linux:虚拟内存区域(VMA,Virtual Memort Area):<br> window:虚拟段(Virtual Section)<br> <img src="//senyee.top/2019/08/04/装载/ELF.png" alt="ELF存储空间到内存的映射关系"><br>3.3 将cup指令寄存器设置成可执行文件入口，启动运行。  </p><blockquote><p>页错误(Page Fault)<br>cpu执行时，发现当前为空页面，产生页错误，将控制权交给操作系统，操作系统找到空页面所在的VMA，进而找到相应页在可执行文件中的偏移(根据3.2建立的映射关系)，然后在物理内存中分配一个物理页，建立物理页与虚拟页之间的映射关系，将控制权交还给进程，进程从页错误的位置继续执行  </p></blockquote><h3 id="五、进程虚拟空间分布"><a href="#五、进程虚拟空间分布" class="headerlink" title="五、进程虚拟空间分布"></a>五、进程虚拟空间分布</h3><ul><li>Segment,一个segment包含多个属性相似的section，映射到一个VMA   </li><li>堆和栈：在进程虚拟空间中以VMA的形式存在，这种VMA叫匿名虚拟内存区域(Anonymous Virtual Memory Area)</li></ul><h3 id="六、段地址对齐"><a href="#六、段地址对齐" class="headerlink" title="六、段地址对齐"></a>六、段地址对齐</h3><h3 id="七、Linux内核装载ELF过程"><a href="#七、Linux内核装载ELF过程" class="headerlink" title="七、Linux内核装载ELF过程"></a>七、Linux内核装载ELF过程</h3><p>。。。</p><blockquote><p>《程序员的自我修养》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 链接与库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装载 </tag>
            
            <tag> 虚拟内存空间分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memory pool</title>
      <link href="/2019/05/18/memory-pool/"/>
      <url>/2019/05/18/memory-pool/</url>
      
        <content type="html"><![CDATA[<h3 id="一、内存"><a href="#一、内存" class="headerlink" title="一、内存"></a>一、内存</h3><ol><li>glibc一次性问内核申请一大块内存，然后划分成很多的小块，这样用户需要使用内存的时候，就直接找到合适的内存给用户，如果释放内存的时候，也是直接由glibc去回收，这样就避免频繁得调用系统调用问内核要内存。</li><li>tcmalloc，它按照线程划分内存块，解决多线程之间对内存申请和释放的竞争问题，提高了效率。</li></ol><h3 id="二、内存池的设计"><a href="#二、内存池的设计" class="headerlink" title="二、内存池的设计"></a>二、内存池的设计</h3><ol><li>考虑方面<br>1.1尺寸<br>1.2</li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>thread pool</title>
      <link href="/2019/05/18/thread-pool/"/>
      <url>/2019/05/18/thread-pool/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 程序基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="线程私有数据"><a href="#线程私有数据" class="headerlink" title="线程私有数据"></a>线程私有数据</h3><h3 id="栈溢出保护"><a href="#栈溢出保护" class="headerlink" title="栈溢出保护"></a>栈溢出保护</h3><h3 id="线程的竞争范围"><a href="#线程的竞争范围" class="headerlink" title="线程的竞争范围"></a>线程的竞争范围</h3><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="1-mutex"><a href="#1-mutex" class="headerlink" title="1.mutex"></a>1.mutex</h4><p>排他性<br>可重入性<br>线程会挂起</p><h4 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2.自旋锁"></a>2.自旋锁</h4><p>一直处于忙状态</p><h4 id="3-CAS-原子操作"><a href="#3-CAS-原子操作" class="headerlink" title="3.CAS 原子操作"></a>3.CAS 原子操作</h4><h4 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4.条件变量"></a>4.条件变量</h4><h4 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5.信号量"></a>5.信号量</h4>]]></content>
      
      
      <categories>
          
          <category> 程序基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp flow control</title>
      <link href="/2019/05/11/tcp-flow-control/"/>
      <url>/2019/05/11/tcp-flow-control/</url>
      
        <content type="html"><![CDATA[<h3 id="一、滑动窗口"><a href="#一、滑动窗口" class="headerlink" title="一、滑动窗口"></a>一、滑动窗口</h3><blockquote><p>接收方根据自己处理消息的速率来控制发送方发送速率的机制。</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;每个socket都有接收缓冲区和发送缓冲区，当接收缓冲区满了，就无法接收数据，这个时候发送方应该停止发送。<br>TCP协议里边有个字段 16位的窗口大小，代表了接收端缓存的剩余空间。接收端在回复ACK时通知给发送方自己缓冲区的剩余大小(三次握手时，确认了接收端窗口的大小)。<br>&ensp;&ensp;&ensp;&ensp;如果连续3次通告了发送端，窗口大小为0，则称为<code>Zero window</code>,不同的协议实现，表现的行为有点不一样。有的，发送端会发送RST消息，把这个TCP连接断掉。<br>&ensp;&ensp;&ensp;&ensp;如果，接收端频繁通告一个较小的窗口，发送端也不停的去把这个窗口填满，那么就会出现大量的小包，这时的带宽利用率是很低的(<code>糊涂窗口</code>)。  </p><p>&ensp;&ensp;&ensp;&ensp;1)如果是接收引起的，一种情况是回复ack(0);另一种是，等待一个合适的窗口大小再通告发送方发送一个较大的包。<code>MSS</code>(TCP包最大的大小，1460字节)。<br>&ensp;&ensp;&ensp;&ensp;2)发送方引起的。<code>Nagle算法</code>:为了避免发送大量小包，发送小包时，等待40ms，把大量的小包组装成一个较大的包，然后发送一个较大的包。TCP选项<code>TCP_NODELAY</code>。</p><p>发送缓冲区里的内容有：1已发送且受到ack，2已发送未收到ack，3未发送的。</p><h3 id="二、MTU"><a href="#二、MTU" class="headerlink" title="二、MTU"></a>二、MTU</h3><ul><li><p>MTU: 由数据链路层规定，最大为1500;  </p></li><li><p>MSS: 最大传输分节(Max Segment Size)，1460=MTU - ip头 - tcp头。建立TCP连接的时候，是由双方去协定的。服务器有一个SMSS,客户端CMSS,<code>MSS = MIN(SMSS, CMSS)</code>;<br>RFC文档里有规定过IP包最小为576个字节。所以，有很多设备，MSS=536个字节。</p></li></ul><h3 id="三、拥塞控制"><a href="#三、拥塞控制" class="headerlink" title="三、拥塞控制"></a>三、拥塞控制</h3><p>拥塞窗口(Congestion window)<br>探测最大的cwnd:  </p><h4 id="1-慢启动"><a href="#1-慢启动" class="headerlink" title="1.慢启动"></a>1.慢启动</h4><p>cwnd = 1MMS 指数增长到阈值thresh</p><h4 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2.拥塞避免"></a>2.拥塞避免</h4><p>cwnd = cwnd + 1MMS</p><h4 id="3-拥塞状态："><a href="#3-拥塞状态：" class="headerlink" title="3.拥塞状态："></a>3.拥塞状态：</h4><p>RTT(Round Trip Time)<br>丢包定时器  </p><ul><li><p>1)如果重发丢的包，依然没有收到ack;或者超时  </p><blockquote><p><code>RENO</code><br>a、thresh = cwnd / 2<br>b、cwnd = 1MSS。<br>c、慢启动  </p></blockquote></li><li><p>2)3次收到同样的ack  </p><blockquote><p><code>NEW RENO</code><br>a、thresh = cwnd / 2<br>b、cwnd = cwnd / 2<br>c、快速恢复阶段</p></blockquote></li></ul><h4 id="4-拥塞控制算法"><a href="#4-拥塞控制算法" class="headerlink" title="4.拥塞控制算法"></a>4.拥塞控制算法</h4><p>CUBIC， SACK<br>google的 <code>BBR</code>算法：linux4.9版本之后，linux内核采纳了该算法  </p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串排序</title>
      <link href="/2019/04/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/04/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目描述<br>对输入的多项式字符串进行解析后计算正确数。<br>规则：包含整数字和逗号,结果类型为字符串，从小到大排列，输出数字间用逗号相连，输出缓冲区128；<br>附加规则：识别非法输入如<code>#*</code><br>我这里假定输入不超过128<br>例：<code>int sort(char *in, char *out)</code><br>输入<code>&quot;1,@10,-11,,1#2,3&quot;</code>,输出<code>-11,1,3</code>,计算正确数为<code>3</code>。</p></blockquote><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define bool char#define true 1#define false 0bool check_first(const char check){    if(check != &#39;-&#39;     &amp;&amp; ( check &lt; &#39;0&#39; || check &gt; &#39;9&#39;) ){        return false;    }    else{        return true;    }}bool isnum(const char num){    if(num &lt;= &#39;9&#39; &amp;&amp; num &gt;= &#39;0&#39;)        return true;    else        return false;}bool isdot(const char dot){    if(&#39;,&#39; == dot)        return true;    else        return false;}bool mv_index2dot(char ** const s){    char *tmp = *s;    tmp++;    while(*tmp != &#39;,&#39;){        if(&#39;\0&#39; == *tmp)            return false;        tmp ++;    }    *tmp = &#39;\0&#39;;    *s = tmp;    return true;}bool isnumstr(char ** const s){    bool ret = true;    char *tmp = *s;    if(isdot(*tmp))        return false;    if( check_first(*tmp) ){        tmp++;        for(;*tmp != &#39;,&#39; &amp;&amp; *tmp != &#39;\0&#39;; ++tmp){            if( !isnum(*tmp) ){                ret = false;                break;            }        }    }    else        ret = false;    *tmp = &#39;\0&#39;;    *s = tmp;    return ret;}int cmp(char *s1, char *s2){    if(&#39;-&#39; == *s1 &amp;&amp; &#39;-&#39; == *s2){        if(strlen(s1) &gt; strlen(s2))            return -1;        else if(strlen(s1) &lt; strlen(s2))            return 1;        else            return (- strcmp(s1, s2));    }    else if(&#39;-&#39; != *s1 &amp;&amp; &#39;-&#39; != *s2){        if(strlen(s1) &gt; strlen(s2))            return 1;        else if(strlen(s1) &lt; strlen(s2))            return -1;        else            return strcmp(s1, s2);    }    else{        if(&#39;-&#39; == *s1)            return -1;        else            return 1;    }}int sort(char *in, char *out){    char *tmp = in;    int cnt = 0;    char *arr_num[128];    int i = 0;    int j = 0;    //解析字符串,判断是否正确    while(*tmp){        arr_num[i] = tmp;        if( isnumstr(&amp;tmp) ){            cnt ++;            i ++;        }        else if(!isdot(*tmp))        {            if( !mv_index2dot(&amp;tmp) )                break;        }        tmp ++;    }    //冒泡排序    for(j = 0; j &lt; cnt-1; ++j){        for(i = 0; i &lt; cnt-j-1; ++i){            if(cmp(arr_num[i],arr_num[i+1]) &gt; 0){                tmp = arr_num[i];                arr_num[i] = arr_num[i+1];                arr_num[i+1] = tmp;            }        }    }    int len = 0;    for(i = 0; i &lt; cnt-1; ++i){        len += sprintf(out+len,&quot;%s,&quot;,arr_num[i]);    }    len += sprintf(out+len,&quot;%s&quot;,arr_num[i]);    return cnt;}int main(){    char c[] = &quot;1,@10,-11,,1#2,3&quot;;    char *out = malloc( sizeof(c) );    memset(out,0,sizeof(c));    int cnt;    cnt = sort(c,out);    printf(&quot;correct num:%d\nsort str: %s\n&quot;,cnt, out);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Bomb Lab</title>
      <link href="/2019/04/03/CSAPP-Bomb-Lab/"/>
      <url>/2019/04/03/CSAPP-Bomb-Lab/</url>
      
        <content type="html"><![CDATA[<h3 id="1-序"><a href="#1-序" class="headerlink" title="1.序"></a>1.序</h3><p>&ensp;&ensp;&ensp;&ensp;CSAPP这本书买好久了，但一直都没看过，最近翻出来看看，做做里面的实验题，做个笔记。第一实验室Bomb，大概意思就是破解密码。输入错误就会BOOM！！目标就是通过反汇编调试找到密码。看到汇编就想到我本科时60几分的微机原理，惭愧惭愧。  </p><h3 id="2-汇编入门"><a href="#2-汇编入门" class="headerlink" title="2.汇编入门"></a>2.汇编入门</h3><p>&ensp;&ensp;&ensp;&ensp;这个实验需要用到基本的汇编，GDB反汇编调试，最好对ELF格式有点了解。用到的工具gdb和objdump。</p><p>&ensp;&ensp;&ensp;&ensp;这里先记一些常用的汇编指令</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">结果</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">mov %rbx, %rdx</td><td style="text-align:center">rdx = rbx</td><td style="text-align:center">这里注意与lea的区别</td></tr><tr><td style="text-align:center">add %rbx, %rdx</td><td style="text-align:center">rdx += rbx</td></tr><tr><td style="text-align:center">sub %rbx, %rdx</td><td style="text-align:center">rdx -= rbx</td></tr><tr><td style="text-align:center">mul %rbx, %rdx</td><td style="text-align:center">rdx *= rbx</td></tr><tr><td style="text-align:center">lea b(%rdx, %rbx, a) %rdx</td><td style="text-align:center">rdx = rdx + a*rbx + b</td><td style="text-align:center">lea取有效地址，括号代表寻址</td></tr><tr><td style="text-align:center">cmp %rbx, %rdx</td><td style="text-align:center">rdx - rbx</td></tr><tr><td style="text-align:center">test %rbx, %rdx</td><td style="text-align:center">rdx &amp; rbx</td></tr></tbody></table><p>&ensp;&ensp;&ensp;&ensp;通用寄存器  </p><blockquote><p>%rax(%eax) 用于做累加<br>%rcx(%ecx) 用于计数<br>%rdx(%edx) 用于保存数据<br>%rbx(%ebx) 用于做内存查找的基础地址<br>%rsi(%esi) 用于保存源索引值<br>%rdi(%edi) 用于保存目标索引值  </p></blockquote><h4 id="Calling-convention"><a href="#Calling-convention" class="headerlink" title="Calling convention"></a>Calling convention</h4><p>这里附上x64 ABI中的calling convention</p><table><thead><tr><th style="text-align:left">Register</th><th style="text-align:left">Usage</th><th style="text-align:center">Preserved across function calls</th></tr></thead><tbody><tr><td style="text-align:left">%rax</td><td style="text-align:left">temporary register; with variable arguments passes information about the number of vector registers used; 1st return register</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%rbx</td><td style="text-align:left">callee-saved register</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:left">%rcx</td><td style="text-align:left">used to pass 4th integer argument to functions</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%rdx</td><td style="text-align:left">used to pass 3rd argument to functions; 2nd return register</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%rsp</td><td style="text-align:left">stack pointer</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:left">%rbp</td><td style="text-align:left">callee-saved register; optionally used as frame pointer</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:left">%rsi</td><td style="text-align:left">used to pass 2nd argument to functions</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%rdi</td><td style="text-align:left">used to pass 1st argument to functions</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%r8</td><td style="text-align:left">used to pass 5th argument to functions</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%r9</td><td style="text-align:left">used to pass 6th argument to functions</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%r10</td><td style="text-align:left">temporary register, used for passing a function’s static chain pointer</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%r11</td><td style="text-align:left">temporary register</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%r12-r14</td><td style="text-align:left">callee-saved registers</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:left">%r15</td><td style="text-align:left">callee-saved register; optionally used as GOT base pointer</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:left">%xmm0–%xmm1</td><td style="text-align:left">used to pass and return floating point arguments</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%xmm2–%xmm7</td><td style="text-align:left">used to pass floating point arguments</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%xmm8–%xmm15</td><td style="text-align:left">temporary registers</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%mmx0–%mmx7</td><td style="text-align:left">temporary registers</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%st0,%st1</td><td style="text-align:left">temporary registers; used to return long double arguments</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%st2–%st7</td><td style="text-align:left">temporary registers</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">%fs</td><td style="text-align:left">Reserved for system (as thread specific data register)</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">mxcsr</td><td style="text-align:left">SSE2 control and status word</td><td style="text-align:center">partial</td></tr><tr><td style="text-align:left">x87 SW</td><td style="text-align:left">x87 status word</td><td style="text-align:center">No</td></tr><tr><td style="text-align:left">x87 CW</td><td style="text-align:left">x87 control word</td><td style="text-align:center">Yes</td></tr></tbody></table><p>&ensp;&ensp;&ensp;&ensp;寄存器中存储着当前正在执行的程序的相关信息：</p><blockquote><p>临时数据存放在 (%rax, …)<br>运行时栈的地址存储在 (%rsp) 中<br>目前的代码控制点存储在 (%rip, …) 中<br>目前测试的状态放在 CF, ZF, SF, OF 中  </p></blockquote><h4 id="CF-ZF-SF-OF"><a href="#CF-ZF-SF-OF" class="headerlink" title="CF, ZF, SF, OF"></a>CF, ZF, SF, OF</h4><p>&ensp;&ensp;&ensp;&ensp;标识位（copy from <a href="https://wdxtub.com/2016/04/16/thin-csapp-2/" target="_blank" rel="noopener">不周山</a>）</p><blockquote><p>CF: Carry Flag (针对无符号数)<br>ZF: Zero Flag<br>SF: Sign Flag (针对有符号数)<br>OF: Overflow Flag (针对有符号数)  </p></blockquote><p>&ensp;&ensp;&ensp;&ensp;可以看到以上这四个标识位，表示四种不同的状态，举个例子，假如我们有一条诸如 t = a + b 的语句，汇编之后假设用的是 addq Src, Dest，那么根据这个操作结果的不同，会相应设置上面提到的四个标识位，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：</p><blockquote><p>1.如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置<br>2.如果 t 等于 0，那么 ZF 标识位会被设置<br>3.如果 t 小于 0，那么 SF 标识位会被设置<br>4.如果 2’s complement 溢出，那么 OF 标识位会被设置为 1（溢出的情况是 (a&gt;0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b<0 && t>=0)）  </0></p></blockquote><p>&ensp;&ensp;&ensp;&ensp;这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 leaq 指令的话不会进行设置。</p><p>&ensp;&ensp;&ensp;&ensp;除了隐形设置，还可以显式进行设置，具体的方法是使用 cmpq 指令，这里的 q 指的是 64 位的地址。具体来说 cmpq Src2(b), Src1(a) 等同于计算 a-b（注意 a b 顺序是颠倒的），然后利用 a-b 的结果来对应进行条件代码的设置：</p><blockquote><p>如果在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置<br>a 和 b 相等时，也就是 a-b 等于零时，ZF 标识位会被设置<br>如果 a &lt; b，也就是 (a-b)<0 时，那么 sf 标识位会被设置 如果 2’s complement 溢出，那么 of 标识位会被设置（溢出的情况是 (a>0 &amp;&amp; b &gt; 0 &amp;&amp; t &lt;0) || (a&lt;0 &amp;&amp; b<0 && t>=0)）  </0></0></p></blockquote><p>&ensp;&ensp;&ensp;&ensp;另一种进行显式设置的方法是使用 testq 指令，具体来说 testq Src2&gt;(b), Src1(a) 等同于计算 a&amp;b（注意 a b 顺序是颠倒的），然后利用 a-b 的结果来对应进行条件代码的设置，通常来说会把其中一个操作数作&gt;为 mask：</p><blockquote><p>当 a&amp;b == 0 时，ZF 标识位会被设置<br>当 a&amp;b &lt; 0 时，SF 标识位会被设置  </p></blockquote><p>&ensp;&ensp;&ensp;&ensp;有了这四个条件码，就可以通过不同的组合方式，来产生不同的条件判断。</p><table><thead><tr><th style="text-align:center">跳转指令</th><th style="text-align:center">跳转条件</th><th style="text-align:center">跳转指令</th><th style="text-align:center">跳转条件</th></tr></thead><tbody><tr><td style="text-align:center">jmp</td><td style="text-align:center">Always jump</td><td style="text-align:center">ja</td><td style="text-align:center">Jump if above(unsigned &gt;)</td></tr><tr><td style="text-align:center">je/jz</td><td style="text-align:center">Jump if eq/zero</td><td style="text-align:center">jae</td><td style="text-align:center">Jump if above / equal</td></tr><tr><td style="text-align:center">jne/jnz</td><td style="text-align:center">Jump if !eq/!zero</td><td style="text-align:center">jb</td><td style="text-align:center">Jump if below(unsigned &lt;)</td></tr><tr><td style="text-align:center">jg</td><td style="text-align:center">Jump if greater</td><td style="text-align:center">jbe</td><td style="text-align:center">Jump if below / equal</td></tr><tr><td style="text-align:center">jge</td><td style="text-align:center">Jump if greater/eq</td><td style="text-align:center">js</td><td style="text-align:center">Jump if sign bits is 1(neg)</td></tr><tr><td style="text-align:center">jl</td><td style="text-align:center">Jump if less</td><td style="text-align:center">jns</td><td style="text-align:center">Jump if sign bit is 0(pos)</td></tr><tr><td style="text-align:center">jle</td><td style="text-align:center">Jump if less / eq</td></tr></tbody></table><h4 id="OBJDUMP"><a href="#OBJDUMP" class="headerlink" title="OBJDUMP"></a>OBJDUMP</h4><pre><code class="c">#-s 将所有段的内容以16进制的方式打印出来#-d 可以将所有包含指令的段反汇编#-x 显示更多段信息objdump -x -d -s bomb &gt; bomb.txt</code></pre><h4 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h4><pre><code class="c">help# 设置断点b 函数名b *地址# 开始运行run# 检查汇编 会给出对应的代码的汇编disas # 查看寄存器内容info registers# 打印指定寄存器p $rsp# 每步执行stepi# 检查寄存器或某个地址x/4wd $rsp</code></pre><h3 id="3-phase-1"><a href="#3-phase-1" class="headerlink" title="3.phase_1"></a>3.phase_1</h3><pre><code>objdump -x -d -s bomb &gt; bomb.txt</code></pre><p>&ensp;&ensp;&ensp;&ensp;思路就是要找到校验密码的地方，通常的做法是：密码输错后都会打印错误提示字符串,在bomb这个程序里面就是<code>&quot;BOOM&quot;</code>,找到这个字符串的地址，再找引用这个字符串的地址，再查找跳转到这个地址的指令，再看指令跳转的条件。这样就能找到校验密码的地方。</p><pre><code>#字符串常量一半存储在.rodata段$cat bomb.txt | grep -n BOOM870: 4025a0 730a000a 424f4f4d 21212100 54686520  s...BOOM!!!.The</code></pre><p>可以看出BOOM的地址在<code>0x4025a0</code>附近,查找引用这个地址的位置</p><pre><code>$ cat bomb.txt | grep -n 4025a870: 4025a0 730a000a 424f4f4d 21212100 54686520  s...BOOM!!!.The 2210:  40143e:    bf a3 25 40 00           mov    $0x4025a3,%edi2212:  401448:    bf ac 25 40 00           mov    $0x4025ac,%edi</code></pre><pre><code>2208 000000000040143a &lt;explode_bomb&gt;:2209   40143a:   48 83 ec 08     sub    $0x8,%rsp2210   40143e:   bf a3 25 40 00  mov    $0x4025a3,%edi                    2211   401443:   e8 c8 f6 ff ff  callq  400b10 &lt;puts@plt&gt;2212   401448:   bf ac 25 40 00  mov    $0x4025ac,%edi2213   40144d:   e8 be f6 ff ff  callq  400b10 &lt;puts@plt&gt;2214   401452:   bf 08 00 00 00  mov    $0x8,%edi2215   401457:   e8 c4 f7 ff ff  callq  400c20 &lt;exit@plt&gt;</code></pre><p>&ensp;&ensp;&ensp;&ensp;可以看到这里就是爆炸地方。然后再找引用<code>&lt;explode_bomb&gt;</code>的位置，就是校验密码的位置了。</p><pre><code>$ cat bomb.txt | grep -n &quot;&lt;explode_bomb&gt;&quot;1765:  400ef2:    e8 43 05 00 00           callq  40143a &lt;explode_bomb&gt;1777:  400f10:    e8 25 05 00 00           callq  40143a &lt;explode_bomb&gt;1783:  400f20:    e8 15 05 00 00           callq  40143a &lt;explode_bomb&gt;1805:  400f65:    e8 d0 04 00 00           callq  40143a &lt;explode_bomb&gt;1824:  400fad:    e8 88 04 00 00           callq  40143a &lt;explode_bomb&gt;1830:  400fc4:    e8 71 04 00 00           callq  40143a &lt;explode_bomb&gt;1869:  401035:    e8 00 04 00 00           callq  40143a &lt;explode_bomb&gt;1878:  401058:    e8 dd 03 00 00           callq  40143a &lt;explode_bomb&gt;1893:  401084:    e8 b1 03 00 00           callq  40143a &lt;explode_bomb&gt;1910:  4010c6:    e8 6f 03 00 00           callq  40143a &lt;explode_bomb&gt;1941:  401123:    e8 12 03 00 00           callq  40143a &lt;explode_bomb&gt;1950:  401140:    e8 f5 02 00 00           callq  40143a &lt;explode_bomb&gt;2001:  4011e9:    e8 4c 02 00 00           callq  40143a &lt;explode_bomb&gt;2046:  401267:    e8 ce 01 00 00           callq  40143a &lt;explode_bomb&gt;2052:  40127d:    e8 b8 01 00 00           callq  40143a &lt;explode_bomb&gt;2208:000000000040143a &lt;explode_bomb&gt;:2232:  401494:    e8 a1 ff ff ff           callq  40143a &lt;explode_bomb&gt;2291:  401595:    e8 a0 fe ff ff           callq  40143a &lt;explode_bomb&gt;</code></pre><p>首先看第一个引用的位置<code>1765行</code></p><pre><code>1759 0000000000400ee0 &lt;phase_1&gt;:1760   400ee0:   48 83 ec 08             sub    $0x8,%rsp1761   400ee4:   be 00 24 40 00          mov    $0x402400,%esi1762   400ee9:   e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt;1763   400eee:   85 c0                   test   %eax,%eax1764   400ef0:   74 05                   je     400ef7 &lt;phase_1+0x17&gt;1765   400ef2:   e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt;1766   400ef7:   48 83 c4 08             add    $0x8,%rsp1767   400efb:   c3                      retq</code></pre><p>这里就是校验密码的位置。这里从函数名大概可以猜下是第一阶段，我们继续确认一下。查找引用<code>&lt;phase_1&gt;</code>的地方</p><pre><code>$ cat bomb.txt | grep -n &quot;&lt;phase_1&gt;&quot;1714:  400e3a:    e8 a1 00 00 00           callq  400ee0 &lt;phase_1&gt;</code></pre><p>查看<code>1714行</code>附近，就找到了程序的入口</p><pre><code>1677 0000000000400da0 &lt;main&gt;:1678   400da0:   53                      push   %rbx...1710   400e28:   bf 78 23 40 00          mov    $0x402378,%edi1711   400e2d:   e8 de fc ff ff          callq  400b10 &lt;puts@plt&gt;1712   400e32:   e8 67 06 00 00          callq  40149e &lt;read_line&gt;1713   400e37:   48 89 c7                mov    %rax,%rdi1714   400e3a:   e8 a1 00 00 00          callq  400ee0 &lt;phase_1&gt;1715   400e3f:   e8 80 07 00 00          callq  4015c4 &lt;phase_defused&gt;1716   400e44:   bf a8 23 40 00          mov    $0x4023a8,%edi1717   400e49:   e8 c2 fc ff ff          callq  400b10 &lt;puts@plt&gt;1718   400e4e:   e8 4b 06 00 00          callq  40149e &lt;read_line&gt;1719   400e53:   48 89 c7                mov    %rax,%rdi1720   400e56:   e8 a1 00 00 00          callq  400efc &lt;phase_2&gt;</code></pre><p>到这里，我们就可以确认<code>&lt;phase_1&gt;</code>就是我们要分析的地方。</p><pre><code>1759 0000000000400ee0 &lt;phase_1&gt;:1760   400ee0:   48 83 ec 08             sub    $0x8,%rsp1761   400ee4:   be 00 24 40 00          mov    $0x402400,%esi</code></pre><p>这里首先开栈，然后到0x402400寻址，字符串通常都是存放在.rodata段的，我们不妨看一下这个地址存的什么。</p><pre><code>844  402400 426f7264 65722072 656c6174 696f6e73  Border relations845  402410 20776974 68204361 6e616461 20686176   with Canada hav846  402420 65206e65 76657220 6265656e 20626574  e never been bet847  402430 7465722e 00000000 576f7721 20596f75  ter.....Wow! You848  402440 27766520 64656675 73656420 74686520  &#39;ve defused the849  402450 73656372 65742073 74616765 2100666c  secret stage!.fl850  402460 79657273 00000000 00000000 00000000  yers............</code></pre><p>这里确实存了一组看起来是密码的字符串，到底是不是，调试一下就知道了。在<code>&lt;phase_1&gt;</code>处下断点，单步调试。</p><pre><code>(gdb) disasDump of assembler code for function phase_1:    0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp    0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi=&gt;  0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;    0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax    0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;    0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;    0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp    0x0000000000400efb &lt;+27&gt;:    retq   End of assembler dump.</code></pre><p>查看%esi的值</p><pre><code>(gdb) x/s $esi0x402400:    &quot;Border relations with Canada have never been better.&quot;</code></pre><p>可以继续分析是哪几个寄存器在比较，但是这里我们可以试下，这个到底是不是我们找的密码呢。</p><pre><code>Phase 1 defused. How about the next one?</code></pre><p>果然就是我们要找的密码。</p><h3 id="4-phase-2"><a href="#4-phase-2" class="headerlink" title="4.phase_2"></a>4.phase_2</h3><p>现在来看下一个引用<code>&lt;explode_bomb&gt;</code>的地方，也就是<code>&lt;phase_2&gt;</code></p><pre><code>1769 0000000000400efc &lt;phase_2&gt;:1770   400efc:   55                      push   %rbp1771   400efd:   53                      push   %rbx1772   400efe:   48 83 ec 28             sub    $0x28,%rsp1773   400f02:   48 89 e6                mov    %rsp,%rsi1774   400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt;1775   400f0a:   83 3c 24 01             cmpl   $0x1,(%rsp)  #栈顶 =11776   400f0e:   74 20                   je     400f30 &lt;phase_2+0x34&gt;1777   400f10:   e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;1778   400f15:   eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;1779   400f17:   8b 43 fc                mov    -0x4(%rbx),%eax1780   400f1a:   01 c0                   add    %eax,%eax1781   400f1c:   39 03                   cmp    %eax,(%rbx)1782   400f1e:   74 05                   je     400f25 &lt;phase_2+0x29&gt;1783   400f20:   e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;1784   400f25:   48 83 c3 04             add    $0x4,%rbx1785   400f29:   48 39 eb                cmp    %rbp,%rbx1786   400f2c:   75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;1787   400f2e:   eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;1788   400f30:   48 8d 5c 24 04          lea    0x4(%rsp),%rbx1789   400f35:   48 8d 6c 24 18          lea    0x18(%rsp),%rbp1790   400f3a:   eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;1791   400f3c:   48 83 c4 28             add    $0x28,%rsp1792   400f40:   5b                      pop    %rbx1793   400f41:   5d                      pop    %rbp1794   400f42:   c3                      retq</code></pre><p>这里看起来输入了6个数字，进入<code>&lt;read_six_numbers&gt;</code>看一看</p><pre><code>2217 000000000040145c &lt;read_six_numbers&gt;:2218   40145c:   48 83 ec 18             sub    $0x18,%rsp2219   401460:   48 89 f2                mov    %rsi,%rdx  # %rsi存放着phase_2的栈顶2220   401463:   48 8d 4e 04             lea    0x4(%rsi),%rcx2221   401467:   48 8d 46 14             lea    0x14(%rsi),%rax2222   40146b:   48 89 44 24 08          mov    %rax,0x8(%rsp)2223   401470:   48 8d 46 10             lea    0x10(%rsi),%rax2224   401474:   48 89 04 24             mov    %rax,(%rsp)2225   401478:   4c 8d 4e 0c             lea    0xc(%rsi),%r92226   40147c:   4c 8d 46 08             lea    0x8(%rsi),%r82227   401480:   be c3 25 40 00          mov    $0x4025c3,%esi  #格式化字符串2228   401485:   b8 00 00 00 00          mov    $0x0,%eax2229   40148a:   e8 61 f7 ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;2230   40148f:   83 f8 05                cmp    $0x5,%eax2231   401492:   7f 05                   jg     401499 &lt;read_six_numbers+0x3d&gt;2232   401494:   e8 a1 ff ff ff          callq  40143a &lt;explode_bomb&gt;2233   401499:   48 83 c4 18             add    $0x18,%rsp2234   40149d:   c3                      retq</code></pre><p>每次循环<code>rbx + 4</code> 等于<code>rsp + 0x18(24)</code>时退出，正好循环6次。</p><pre><code>1779   400f17:   8b 43 fc                mov    -0x4(%rbx),%eax1780   400f1a:   01 c0                   add    %eax,%eax1781   400f1c:   39 03                   cmp    %eax,(%rbx)</code></pre><p>从上面算出<code>*rbx = (*(rbx-4))*2</code>  这6个数就是个公比为2的等比数列，其中要求栈顶值为<code>1</code>。<br>在<code>&lt;read_six_numbers&gt;</code>中，根据调用约定，得出phase_2栈顶用来存储第一个数字。所以答案为：</p><pre><code>1 2 4 8 16 32That&#39;s number 2.  Keep going!</code></pre><p>Bingo!!</p><h3 id="5-phase-3"><a href="#5-phase-3" class="headerlink" title="5.phase_3"></a>5.phase_3</h3><pre><code>1796 0000000000400f43 &lt;phase_3&gt;:1797   400f43:   48 83 ec 18             sub    $0x18,%rsp1798   400f47:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx #num21799   400f4c:   48 8d 54 24 08          lea    0x8(%rsp),%rdx #num11800   400f51:   be cf 25 40 00          mov    $0x4025cf,%esi1801   400f56:   b8 00 00 00 00          mov    $0x0,%eax1802   400f5b:   e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;1803   400f60:   83 f8 01                cmp    $0x1,%eax             #1.判断sscanf返回值&gt;11804   400f63:   7f 05                   jg     400f6a &lt;phase_3+0x27&gt; #2.跳转1805   400f65:   e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;1806   400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)        #3.判断num1 &lt; 71807   400f6f:   77 3c                   ja     400fad &lt;phase_3+0x6a&gt;1808   400f71:   8b 44 24 08             mov    0x8(%rsp),%eax        #4.eax = num11809   400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)    #5.switch case (num1)1810   400f7c:   b8 cf 00 00 00          mov    $0xcf,%eax            #6.1811   400f81:   eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt; 1812   400f83:   b8 c3 02 00 00          mov    $0x2c3,%eax           #7.1813   400f88:   eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt; 1814   400f8a:   b8 00 01 00 00          mov    $0x100,%eax           #8.1815   400f8f:   eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt; 1816   400f91:   b8 85 01 00 00          mov    $0x185,%eax           #9.1817   400f96:   eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt; 1818   400f98:   b8 ce 00 00 00          mov    $0xce,%eax            #10.1819   400f9d:   eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt; 1820   400f9f:   b8 aa 02 00 00          mov    $0x2aa,%eax           #11.1821   400fa4:   eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt; 1822   400fa6:   b8 47 01 00 00          mov    $0x147,%eax           #12.1823   400fab:   eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt; 1824   400fad:   e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;1825   400fb2:   b8 00 00 00 00          mov    $0x0,%eax1826   400fb7:   eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;1827   400fb9:   b8 37 01 00 00          mov    $0x137,%eax1828   400fbe:   3b 44 24 0c             cmp    0xc(%rsp),%eax1829   400fc2:   74 05                   je     400fc9 &lt;phase_3+0x86&gt;1830   400fc4:   e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;1831   400fc9:   48 83 c4 18             add    $0x18,%rsp1832   400fcd:   c3                      retq</code></pre><p>这里使用<code>sscanf</code>输入，就要传入格式化字符串，查看<code>0x400f56</code>内指向的值。</p><pre><code>(gdb) x/s 0x4025cf0x4025cf:       &quot;%d %d&quot;</code></pre><p>该阶段会输入两个数字。分别存在<code>%rdx,%rcx</code>指向的地址中。<br><code>1809   400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)</code>按指针来描述就是跳转到 <em>(0x0x402470+8</em>rax)，既然是跳转，所以<code>0x0x402470</code>里存的也是地址。实际上这里就是一个跳转表。disas可以看到地址的长度是8字节，是个64位程序。</p><pre><code>(gdb) x/8xg 0x4024700x402470:       0x0000000000400f7c      0x0000000000400fb90x402480:       0x0000000000400f83      0x0000000000400f8a0x402490:       0x0000000000400f91      0x0000000000400f980x4024a0:       0x0000000000400f9f      0x0000000000400fa6</code></pre><p>这里有8个跳转地址，与num1 取值[0,7]时一一对应，所以这里的答案有8种：（0，207）、（1，311）、（2，707）、（3，256）、（4，389）、（5，206）、（6，682）、（7，327）。</p><h3 id="6-phase-4"><a href="#6-phase-4" class="headerlink" title="6.phase_4"></a>6.phase_4</h3><pre><code>1858 000000000040100c &lt;phase_4&gt;:1859   40100c:   48 83 ec 18             sub    $0x18,%rsp1860   401010:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx1861   401015:   48 8d 54 24 08          lea    0x8(%rsp),%rdx1862   40101a:   be cf 25 40 00          mov    $0x4025cf,%esi1863   40101f:   b8 00 00 00 00          mov    $0x0,%eax1864   401024:   e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;1865   401029:   83 f8 02                cmp    $0x2,%eax1866   40102c:   75 07                   jne    401035 &lt;phase_4+0x29&gt;1867   40102e:   83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp) # num1 &lt; 141868   401033:   76 05                   jbe    40103a &lt;phase_4+0x2e&gt;1869   401035:   e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;1870   40103a:   ba 0e 00 00 00          mov    $0xe,%edx1871   40103f:   be 00 00 00 00          mov    $0x0,%esi1872   401044:   8b 7c 24 08             mov    0x8(%rsp),%edi1873   401048:   e8 81 ff ff ff          callq  400fce &lt;func4&gt;1874   40104d:   85 c0                   test   %eax,%eax  #返回值为01875   40104f:   75 07                   jne    401058 &lt;phase_4+0x4c&gt;1876   401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)  #num2 == 01877   401056:   74 05                   je     40105d &lt;phase_4+0x51&gt;1878   401058:   e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;1879   40105d:   48 83 c4 18             add    $0x18,%rsp1880   401061:   c3                      retq</code></pre><p>这里输入参数时与上个阶段是一样的，输入两个数字<code>num1，num2</code></p><pre><code>(gdb) x/s 0x4025cf0x4025cf:       &quot;%d %d&quot;</code></pre><p>初步分析可以得到<code>num1&lt;14,num2=0</code>, 向<code>func4</code>传了3个参数,假设为<code>func4(int a,int b, int c)</code>，判断<code>func4(a,0,14)</code>的返回值为0时成功。<br>进入<code>func4</code>可以发现是个递归函数。</p><pre><code>1834 0000000000400fce &lt;func4&gt;:1835   400fce:   48 83 ec 08             sub    $0x8,%rsp1836   400fd2:   89 d0                   mov    %edx,%eax #第3个参数1837   400fd4:   29 f0                   sub    %esi,%eax #第2个参数1838   400fd6:   89 c1                   mov    %eax,%ecx1839   400fd8:   c1 e9 1f                shr    $0x1f,%ecx #ecx &gt;&gt;= 0x1f1840   400fdb:   01 c8                   add    %ecx,%eax1841   400fdd:   d1 f8                   sar    %eax #算术右移&gt;&gt;11842   400fdf:   8d 0c 30                lea    (%rax,%rsi,1),%ecx #ecx = rax + 1*rsi1843   400fe2:   39 f9                   cmp    %edi,%ecx #第1个参数1844   400fe4:   7e 0c                   jle    400ff2 &lt;func4+0x24&gt;1845   400fe6:   8d 51 ff                lea    -0x1(%rcx),%edx1846   400fe9:   e8 e0 ff ff ff          callq  400fce &lt;func4&gt;1847   400fee:   01 c0                   add    %eax,%eax1848   400ff0:   eb 15                   jmp    401007 &lt;func4+0x39&gt;1849   400ff2:   b8 00 00 00 00          mov    $0x0,%eax1850   400ff7:   39 f9                   cmp    %edi,%ecx 1851   400ff9:   7d 0c                   jge    401007 &lt;func4+0x39&gt;1852   400ffb:   8d 71 01                lea    0x1(%rcx),%esi1853   400ffe:   e8 cb ff ff ff          callq  400fce &lt;func4&gt;1854   401003:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax1855   401007:   48 83 c4 08             add    $0x8,%rsp1856   40100b:   c3                      retq</code></pre><p>大概的c实现如下：</p><pre><code class="c">//                %edi    %esi   %edxstatic int func4(int a, int b, int c){    int tmp = (((c - b) + ((c - b) &gt;&gt; 31)) &gt;&gt; 1) + b;    if (tmp &lt;= a)     {        if (tmp &gt;= a)  //等于a时结束        {            return (0);        }         else         {            return func4(a, b + 1, c) * 2 + 1;        }    }     else     {        return func4(a, b, c - 1) * 2;    }}</code></pre><p>这里根据<code>num1&lt;14,num2=0</code>这个条件，遍历出所有的自然数答案<code>（0,0）、（1,0）、（3,0）、（7,0）</code>。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char *argv[]){    int i, result;    for (i = 0; i &lt; 14; ++i)     {        result = func4(i, 0, 14);        if (result == 0)         {            printf(&quot;%d\n&quot;, i);        }    }    return 0;}</code></pre><h3 id="7-phase-5"><a href="#7-phase-5" class="headerlink" title="7.phase_5"></a>7.phase_5</h3><p>待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obj</title>
      <link href="/2019/04/01/obj/"/>
      <url>/2019/04/01/obj/</url>
      
        <content type="html"><![CDATA[<h3 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h3><ul><li>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号<blockquote><p>规则一：不允许强符号多次定义；如果有多个强符号，则链接器报符号重复定义错误。<br>规则二：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。<br>规则三：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。  </p></blockquote></li><li>尽量不要使用多个不用类型的弱符号，否则容易导致很难发现的程序错误。  </li></ul><h3 id="弱引用和强引用"><a href="#弱引用和强引用" class="headerlink" title="弱引用和强引用"></a>弱引用和强引用</h3><ul><li><p>强引用：链接器找不到该符号的定义，就用报符号未定义错误。</p></li><li><p>弱引用：如果引用符号未被定义，链接器不报错。链接器默认未定义的弱引用为0或者一个特殊值，以便程序代码能够识别。</p></li></ul><pre><code class="c">//gcc不会报链接错误，但是会发生运行错误。因为foo函数的地址为0,会发生非法访问。__attribute__ ((weakref)) void foo();int main(){    foo();    return 0;}</code></pre><pre><code class="c">//一个改进的例子。当foo没定义时不执行foo__attribute__ ((weakref)) void foo();int main(){    if(foo)        foo();    return 0;}</code></pre><ul><li>弱符号和弱引用对于库来说十分有用。  <blockquote><p>如果一个程序被设计成可以支持单线程或者多线程的模式，就可以通过弱引用判断当前的程序是链接到了单线程Glibc库还是多线程的Glibc库。</p></blockquote></li></ul><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;int pthread_create(    pthread_t*,    const pthread_attr_t*,    void* (*)(void*),    void*) __attribute__ ((weak));int main(){    if(pthread_create)        printf(&quot;This is multi-thread version!\n&quot;);    else    //当链接单线程的Glibc库时，pthread_create未定义，函数地址为0        printf(&quot;This is single-thread version!\n&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 链接与库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/31/hello-world/"/>
      <url>/2019/03/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/senyee" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
