[{"title":"CSAPP Bomb Lab","url":"/2019/04/03/CSAPP-Bomb-Lab/","content":"\n### 1.序\n\n&ensp;&ensp;&ensp;&ensp;CSAPP这本书买好久了，但一直都没看过，最近翻出来看看，做做里面的实验题，做个笔记。第一实验室Bomb，大概意思就是破解密码。输入错误就会BOOM！！目标就是通过反汇编调试找到密码。看到汇编就想到我本科时60几分的微机原理，惭愧惭愧。  \n\n### 2.汇编入门\n\n&ensp;&ensp;&ensp;&ensp;这个实验需要用到基本的汇编，GDB反汇编调试，最好对ELF格式有点了解。用到的工具gdb和objdump。\n\n&ensp;&ensp;&ensp;&ensp;这里先记一些常用的汇编指令\n\n指令 | 结果 | 描述\n:-: | :-:| :-: |\nmov %rbx, %rdx | rdx = rbx | 这里注意与lea的区别\nadd %rbx, %rdx | rdx += rbx\nsub %rbx, %rdx | rdx -= rbx\nmul %rbx, %rdx | rdx *= rbx\nlea b(%rdx, %rbx, a) %rdx | rdx = rdx + a*rbx + b |lea取有效地址，括号代表寻址\ncmp %rbx, %rdx | rdx - rbx\ntest %rbx, %rdx | rdx & rbx\n\n&ensp;&ensp;&ensp;&ensp;通用寄存器  \n> %rax(%eax) 用于做累加   \n> %rcx(%ecx) 用于计数  \n> %rdx(%edx) 用于保存数据  \n> %rbx(%ebx) 用于做内存查找的基础地址  \n> %rsi(%esi) 用于保存源索引值  \n> %rdi(%edi) 用于保存目标索引值  \n\n&ensp;&ensp;&ensp;&ensp;寄存器中存储着当前正在执行的程序的相关信息：\n\n>临时数据存放在 (%rax, …)  \n>运行时栈的地址存储在 (%rsp) 中  \n>目前的代码控制点存储在 (%rip, …) 中  \n>目前测试的状态放在 CF, ZF, SF, OF 中  \n\n&ensp;&ensp;&ensp;&ensp;标识位（copy from [不周山](https://wdxtub.com/2016/04/16/thin-csapp-2/)）\n>CF: Carry Flag (针对无符号数)  \n>ZF: Zero Flag  \n>SF: Sign Flag (针对有符号数)  \n>OF: Overflow Flag (针对有符号数)  \n\n&ensp;&ensp;&ensp;&ensp;可以看到以上这四个标识位，表示四种不同的状态，举个例子，假如我们有一条诸如 t = a + b 的语句，汇编之后假设用的是 addq Src, Dest，那么根据这个操作结果的不同，会相应设置上面提到的四个标识位，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：\n\n>1.如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置  \n>2.如果 t 等于 0，那么 ZF 标识位会被设置  \n>3.如果 t 小于 0，那么 SF 标识位会被设置  \n>4.如果 2’s complement 溢出，那么 OF 标识位会被设置为 1（溢出的情况是 (a>0 && b > 0 && t <0) || (a<0 && b<0 && t>=0)）  \n\n&ensp;&ensp;&ensp;&ensp;这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 leaq 指令的话不会进行设置。\n\n&ensp;&ensp;&ensp;&ensp;除了隐形设置，还可以显式进行设置，具体的方法是使用 cmpq 指令，这里的 q 指的是 64 位的地址。具体来说 cmpq Src2(b), Src1(a) 等同于计算 a-b（注意 a b 顺序是颠倒的），然后利用 a-b 的结果来对应进行条件代码的设置：\n\n>如果在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置  \n>a 和 b 相等时，也就是 a-b 等于零时，ZF 标识位会被设置  \n>如果 a < b，也就是 (a-b)<0 时，那么 SF 标识位会被设置  \n>如果 2’s complement 溢出，那么 OF 标识位会被设置（溢出的情况是 (a>0 && b > 0 && t <0) || (a<0 && b<0 && t>=0)）  \n\n&ensp;&ensp;&ensp;&ensp;另一种进行显式设置的方法是使用 testq 指令，具体来说 testq Src2>(b), Src1(a) 等同于计算 a&b（注意 a b 顺序是颠倒的），然后利用 a-b 的结果来对应进行条件代码的设置，通常来说会把其中一个操作数作>为 mask：\n\n>当 a&b == 0 时，ZF 标识位会被设置  \n>当 a&b < 0 时，SF 标识位会被设置  \n\n&ensp;&ensp;&ensp;&ensp;有了这四个条件码，就可以通过不同的组合方式，来产生不同的条件判断。\n\n跳转指令 | 跳转条件 | 跳转指令 | 跳转条件\n:-: | :-: | :-: | :-: \njmp     | Always jump       | ja  | Jump if above(unsigned >)\nje/jz   | Jump if eq/zero   | jae | Jump if above / equal\njne/jnz | Jump if !eq/!zero | jb  | Jump if below(unsigned <)\njg      | Jump if greater   | jbe | Jump if below / equal\njge     | Jump if greater/eq| js  | Jump if sign bits is 1(neg)\njl      | Jump if less      | jns | Jump if sign bit is 0(pos)\njle     | Jump if less / eq\n\n#### OBJDUMP\n\n```c\n#-s 将所有段的内容以16进制的方式打印出来\n#-d 可以将所有包含指令的段反汇编\n#-x 显示更多段信息\nobjdump -x -d -s bomb > bomb.txt\n```\n\n#### GDB\n```c\nhelp\n# 设置断点\nb 函数名\nb *地址\n\n# 开始运行\nrun\n\n# 检查汇编 会给出对应的代码的汇编\ndisas \n\n# 查看寄存器内容\ninfo registers\n\n# 打印指定寄存器\np $rsp\n\n# 每步执行\nstepi\n\n# 检查寄存器或某个地址\nx/4wd $rsp\n```\n\n### 3.phase_1\n```\nobjdump -x -d -s bomb > bomb.txt\n```\n&ensp;&ensp;&ensp;&ensp;思路就是要找到校验密码的地方，通常的做法是：密码输错后都会打印错误提示字符串,在bomb这个程序里面就是`\"BOOM\"`,找到这个字符串的地址，再找引用这个字符串的地址，再查找跳转到这个地址的指令，再看指令跳转的条件。这样就能找到校验密码的地方。\n\n```\n#字符串常量一半存储在.rodata段\n$cat bomb.txt | grep -n BOOM\n870: 4025a0 730a000a 424f4f4d 21212100 54686520  s...BOOM!!!.The\n```\n\n可以看出BOOM的地址在`0x4025a0`附近,查找引用这个地址的位置\n```\n$ cat bomb.txt | grep -n 4025a\n\n870: 4025a0 730a000a 424f4f4d 21212100 54686520  s...BOOM!!!.The \n2210:  40143e:    bf a3 25 40 00           mov    $0x4025a3,%edi\n2212:  401448:    bf ac 25 40 00           mov    $0x4025ac,%edi\n```\n```\n2208 000000000040143a <explode_bomb>:\n2209   40143a:   48 83 ec 08     sub    $0x8,%rsp\n2210   40143e:   bf a3 25 40 00  mov    $0x4025a3,%edi                    \n2211   401443:   e8 c8 f6 ff ff  callq  400b10 <puts@plt>\n2212   401448:   bf ac 25 40 00  mov    $0x4025ac,%edi\n2213   40144d:   e8 be f6 ff ff  callq  400b10 <puts@plt>\n2214   401452:   bf 08 00 00 00  mov    $0x8,%edi\n2215   401457:   e8 c4 f7 ff ff  callq  400c20 <exit@plt>\n```\n&ensp;&ensp;&ensp;&ensp;可以看到这里就是爆炸地方。然后再找引用`<explode_bomb>`的位置，就是校验密码的位置了。\n```\n$ cat bomb.txt | grep -n \"<explode_bomb>\"\n\n1765:  400ef2:    e8 43 05 00 00           callq  40143a <explode_bomb>\n1777:  400f10:    e8 25 05 00 00           callq  40143a <explode_bomb>\n1783:  400f20:    e8 15 05 00 00           callq  40143a <explode_bomb>\n1805:  400f65:    e8 d0 04 00 00           callq  40143a <explode_bomb>\n1824:  400fad:    e8 88 04 00 00           callq  40143a <explode_bomb>\n1830:  400fc4:    e8 71 04 00 00           callq  40143a <explode_bomb>\n1869:  401035:    e8 00 04 00 00           callq  40143a <explode_bomb>\n1878:  401058:    e8 dd 03 00 00           callq  40143a <explode_bomb>\n1893:  401084:    e8 b1 03 00 00           callq  40143a <explode_bomb>\n1910:  4010c6:    e8 6f 03 00 00           callq  40143a <explode_bomb>\n1941:  401123:    e8 12 03 00 00           callq  40143a <explode_bomb>\n1950:  401140:    e8 f5 02 00 00           callq  40143a <explode_bomb>\n2001:  4011e9:    e8 4c 02 00 00           callq  40143a <explode_bomb>\n2046:  401267:    e8 ce 01 00 00           callq  40143a <explode_bomb>\n2052:  40127d:    e8 b8 01 00 00           callq  40143a <explode_bomb>\n2208:000000000040143a <explode_bomb>:\n2232:  401494:    e8 a1 ff ff ff           callq  40143a <explode_bomb>\n2291:  401595:    e8 a0 fe ff ff           callq  40143a <explode_bomb>\n```\n首先看第一个引用的位置`1765行`\n```\n1759 0000000000400ee0 <phase_1>:\n1760   400ee0:   48 83 ec 08             sub    $0x8,%rsp\n1761   400ee4:   be 00 24 40 00          mov    $0x402400,%esi\n1762   400ee9:   e8 4a 04 00 00          callq  401338 <strings_not_equal>\n1763   400eee:   85 c0                   test   %eax,%eax\n1764   400ef0:   74 05                   je     400ef7 <phase_1+0x17>\n1765   400ef2:   e8 43 05 00 00          callq  40143a <explode_bomb>\n1766   400ef7:   48 83 c4 08             add    $0x8,%rsp\n1767   400efb:   c3                      retq\n\n```\n这里就是校验密码的位置。这里从函数名大概可以猜下是第一阶段，我们继续确认一下。查找引用`<phase_1>`的地方\n```\n$ cat bomb.txt | grep -n \"<phase_1>\"\n\n1714:  400e3a:    e8 a1 00 00 00           callq  400ee0 <phase_1>\n```\n查看`1714行`附近，就找到了程序的入口\n```\n1677 0000000000400da0 <main>:\n1678   400da0:   53                      push   %rbx\n...\n1710   400e28:   bf 78 23 40 00          mov    $0x402378,%edi\n1711   400e2d:   e8 de fc ff ff          callq  400b10 <puts@plt>\n1712   400e32:   e8 67 06 00 00          callq  40149e <read_line>\n1713   400e37:   48 89 c7                mov    %rax,%rdi\n1714   400e3a:   e8 a1 00 00 00          callq  400ee0 <phase_1>\n1715   400e3f:   e8 80 07 00 00          callq  4015c4 <phase_defused>\n1716   400e44:   bf a8 23 40 00          mov    $0x4023a8,%edi\n1717   400e49:   e8 c2 fc ff ff          callq  400b10 <puts@plt>\n1718   400e4e:   e8 4b 06 00 00          callq  40149e <read_line>\n1719   400e53:   48 89 c7                mov    %rax,%rdi\n1720   400e56:   e8 a1 00 00 00          callq  400efc <phase_2>\n\n```\n到这里，我们就可以确认`<phase_1>`就是我们要分析的地方。\n\n```\n1759 0000000000400ee0 <phase_1>:\n1760   400ee0:   48 83 ec 08             sub    $0x8,%rsp\n1761   400ee4:   be 00 24 40 00          mov    $0x402400,%esi\n```\n这里首先开栈，然后到0x402400寻址，字符串通常都是存放在.rodata段的，我们不妨看一下这个地址存的什么。\n```\n844  402400 426f7264 65722072 656c6174 696f6e73  Border relations\n845  402410 20776974 68204361 6e616461 20686176   with Canada hav\n846  402420 65206e65 76657220 6265656e 20626574  e never been bet\n847  402430 7465722e 00000000 576f7721 20596f75  ter.....Wow! You\n848  402440 27766520 64656675 73656420 74686520  've defused the\n849  402450 73656372 65742073 74616765 2100666c  secret stage!.fl\n850  402460 79657273 00000000 00000000 00000000  yers............\n```\n这里确实存了一组看起来是密码的字符串，到底是不是，调试一下就知道了。在`<phase_1>`处下断点，单步调试。\n```\n(gdb) disas\nDump of assembler code for function phase_1:\n    0x0000000000400ee0 <+0>:     sub    $0x8,%rsp\n    0x0000000000400ee4 <+4>:     mov    $0x402400,%esi\n=>  0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>\n    0x0000000000400eee <+14>:    test   %eax,%eax\n    0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>\n    0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>\n    0x0000000000400ef7 <+23>:    add    $0x8,%rsp\n    0x0000000000400efb <+27>:    retq   \nEnd of assembler dump.\n```\n查看%esi的值\n```\n(gdb) x/s $esi\n0x402400:    \"Border relations with Canada have never been better.\"\n```\n可以继续分析是哪几个寄存器在比较，但是这里我们可以试下，这个到底是不是我们找的密码呢。\n```\nPhase 1 defused. How about the next one?\n```\n果然就是我们要找的密码。\n\n### 4.phase_2\n\n\n\n","tags":["CSAPP","汇编"]},{"title":"obj","url":"/2019/04/01/obj/","content":"\n### 弱符号与强符号\n\n* 编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号\n>规则一：不允许强符号多次定义；如果有多个强符号，则链接器报符号重复定义错误。  \n>规则二：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。  \n>规则三：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。  \n* 尽量不要使用多个不用类型的弱符号，否则容易导致很难发现的程序错误。  \n\n### 弱引用和强引用\n\n* 强引用：链接器找不到该符号的定义，就用报符号未定义错误。\n\n* 弱引用：如果引用符号未被定义，链接器不报错。链接器默认未定义的弱引用为0或者一个特殊值，以便程序代码能够识别。\n\n```c\n//gcc不会报链接错误，但是会发生运行错误。因为foo函数的地址为0,会发生非法访问。\n__attribute__ ((weakref)) void foo();\nint main()\n{\n    foo();\n    return 0;\n}\n```\n\n```c\n//一个改进的例子。当foo没定义时不执行foo\n__attribute__ ((weakref)) void foo();\nint main()\n{\n    if(foo)\n        foo();\n    return 0;\n}\n```\n\n* 弱符号和弱引用对于库来说十分有用。  \n>如果一个程序被设计成可以支持单线程或者多线程的模式，就可以通过弱引用判断当前的程序是链接到了单线程Glibc库还是多线程的Glibc库。\n\n```c\n#include <stdio.h>\n#include <pthread.h>\nint pthread_create(\n    pthread_t*,\n    const pthread_attr_t*,\n    void* (*)(void*),\n    void*) __attribute__ ((weak));\n\nint main()\n{\n    if(pthread_create)\n        printf(\"This is multi-thread version!\\n\");\n    else    //当链接单线程的Glibc库时，pthread_create未定义，函数地址为0\n        printf(\"This is single-thread version!\\n\");\n    return 0;\n}\n```\n\n","tags":["链接"]},{"title":"Hello World","url":"/2019/03/31/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/senyee).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]