[{"title":"CSAPP Bomb Lab","url":"/2019/04/03/CSAPP-Bomb-Lab/","content":"\n\n### 1.序\n\n&ensp;&ensp;&ensp;&ensp;CSAPP这本书买好久了，但一直都没看过，最近翻出来看看，做做里面的实验题，做个笔记。第一实验室Bomb，大概意思就是破解密码。输入错误就会BOOM！！目标就是通过反汇编调试找到密码。看到汇编就想到我本科时60几分的微机原理，惭愧惭愧。  \n\n### 2.汇编入门\n\n&ensp;&ensp;&ensp;&ensp;这个实验需要用到基本的汇编，GDB反汇编调试，最好对ELF格式有点了解。用到的工具gdb和objdump。\n\n&ensp;&ensp;&ensp;&ensp;这里先记一些常用的汇编指令\n\n指令 | 结果 | 描述\n:-: | :-:| :-: |\nmov %rbx, %rdx | rdx = rbx | 这里注意与lea的区别\nadd %rbx, %rdx | rdx += rbx\nsub %rbx, %rdx | rdx -= rbx\nmul %rbx, %rdx | rdx *= rbx\nlea b(%rdx, %rbx, a) %rdx | rdx = rdx + a*rbx + b |lea取有效地址，括号代表寻址\ncmp %rbx, %rdx | rdx - rbx\ntest %rbx, %rdx | rdx & rbx\n\n&ensp;&ensp;&ensp;&ensp;通用寄存器  \n> %rax(%eax) 用于做累加   \n> %rcx(%ecx) 用于计数  \n> %rdx(%edx) 用于保存数据  \n> %rbx(%ebx) 用于做内存查找的基础地址  \n> %rsi(%esi) 用于保存源索引值  \n> %rdi(%edi) 用于保存目标索引值  \n\n#### Calling convention\n这里附上x64 ABI中的calling convention\nRegister | Usage | Preserved across function calls\n:- | :- | :-: \n%rax | temporary register; with variable arguments passes information about the number of vector registers used; 1st return register | No\n%rbx | callee-saved register | Yes\n%rcx | used to pass 4th integer argument to functions | No\n%rdx | used to pass 3rd argument to functions; 2nd return register | No\n%rsp | stack pointer | Yes\n%rbp | callee-saved register; optionally used as frame pointer | Yes\n%rsi | used to pass 2nd argument to functions | No\n%rdi | used to pass 1st argument to functions | No\n%r8  | used to pass 5th argument to functions | No\n%r9  | used to pass 6th argument to functions | No\n%r10 | temporary register, used for passing a function’s static chain pointer | No\n%r11 | temporary register | No\n%r12-r14 | callee-saved registers | Yes\n%r15 | callee-saved register; optionally used as GOT base pointer | Yes\n%xmm0–%xmm1  | used to pass and return floating point arguments | No\n%xmm2–%xmm7  | used to pass floating point arguments | No\n%xmm8–%xmm15 | temporary registers | No\n%mmx0–%mmx7  | temporary registers | No\n%st0,%st1 | temporary registers; used to return long double arguments | No\n%st2–%st7 | temporary registers | No\n%fs | Reserved for system (as thread specific data register) | No\nmxcsr  | SSE2 control and status word | partial\nx87 SW | x87 status word | No\nx87 CW | x87 control word | Yes\n\n&ensp;&ensp;&ensp;&ensp;寄存器中存储着当前正在执行的程序的相关信息：\n\n>临时数据存放在 (%rax, …)  \n>运行时栈的地址存储在 (%rsp) 中  \n>目前的代码控制点存储在 (%rip, …) 中  \n>目前测试的状态放在 CF, ZF, SF, OF 中  \n\n####  CF, ZF, SF, OF\n&ensp;&ensp;&ensp;&ensp;标识位（copy from [不周山](https://wdxtub.com/2016/04/16/thin-csapp-2/)）\n>CF: Carry Flag (针对无符号数)  \n>ZF: Zero Flag  \n>SF: Sign Flag (针对有符号数)  \n>OF: Overflow Flag (针对有符号数)  \n\n&ensp;&ensp;&ensp;&ensp;可以看到以上这四个标识位，表示四种不同的状态，举个例子，假如我们有一条诸如 t = a + b 的语句，汇编之后假设用的是 addq Src, Dest，那么根据这个操作结果的不同，会相应设置上面提到的四个标识位，而因为这个是执行类似操作时顺带尽心设置的，称为隐式设置，例如：\n\n>1.如果两个数相加，在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置  \n>2.如果 t 等于 0，那么 ZF 标识位会被设置  \n>3.如果 t 小于 0，那么 SF 标识位会被设置  \n>4.如果 2’s complement 溢出，那么 OF 标识位会被设置为 1（溢出的情况是 (a>0 && b > 0 && t <0) || (a<0 && b<0 && t>=0)）  \n\n&ensp;&ensp;&ensp;&ensp;这就发现了，其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。注意，使用 leaq 指令的话不会进行设置。\n\n&ensp;&ensp;&ensp;&ensp;除了隐形设置，还可以显式进行设置，具体的方法是使用 cmpq 指令，这里的 q 指的是 64 位的地址。具体来说 cmpq Src2(b), Src1(a) 等同于计算 a-b（注意 a b 顺序是颠倒的），然后利用 a-b 的结果来对应进行条件代码的设置：\n\n>如果在最高位还需要进位（也就是溢出了），那么 CF 标识位就会被设置  \n>a 和 b 相等时，也就是 a-b 等于零时，ZF 标识位会被设置  \n>如果 a < b，也就是 (a-b)<0 时，那么 SF 标识位会被设置  \n>如果 2’s complement 溢出，那么 OF 标识位会被设置（溢出的情况是 (a>0 && b > 0 && t <0) || (a<0 && b<0 && t>=0)）  \n\n&ensp;&ensp;&ensp;&ensp;另一种进行显式设置的方法是使用 testq 指令，具体来说 testq Src2>(b), Src1(a) 等同于计算 a&b（注意 a b 顺序是颠倒的），然后利用 a-b 的结果来对应进行条件代码的设置，通常来说会把其中一个操作数作>为 mask：\n\n>当 a&b == 0 时，ZF 标识位会被设置  \n>当 a&b < 0 时，SF 标识位会被设置  \n\n&ensp;&ensp;&ensp;&ensp;有了这四个条件码，就可以通过不同的组合方式，来产生不同的条件判断。\n\n跳转指令 | 跳转条件 | 跳转指令 | 跳转条件\n:-: | :-: | :-: | :-: \njmp     | Always jump       | ja  | Jump if above(unsigned >)\nje/jz   | Jump if eq/zero   | jae | Jump if above / equal\njne/jnz | Jump if !eq/!zero | jb  | Jump if below(unsigned <)\njg      | Jump if greater   | jbe | Jump if below / equal\njge     | Jump if greater/eq| js  | Jump if sign bits is 1(neg)\njl      | Jump if less      | jns | Jump if sign bit is 0(pos)\njle     | Jump if less / eq\n\n#### OBJDUMP\n\n```c\n#-s 将所有段的内容以16进制的方式打印出来\n#-d 可以将所有包含指令的段反汇编\n#-x 显示更多段信息\nobjdump -x -d -s bomb > bomb.txt\n```\n\n#### GDB\n```c\nhelp\n# 设置断点\nb 函数名\nb *地址\n\n# 开始运行\nrun\n\n# 检查汇编 会给出对应的代码的汇编\ndisas \n\n# 查看寄存器内容\ninfo registers\n\n# 打印指定寄存器\np $rsp\n\n# 每步执行\nstepi\n\n# 检查寄存器或某个地址\nx/4wd $rsp\n```\n\n### 3.phase_1\n```\nobjdump -x -d -s bomb > bomb.txt\n```\n&ensp;&ensp;&ensp;&ensp;思路就是要找到校验密码的地方，通常的做法是：密码输错后都会打印错误提示字符串,在bomb这个程序里面就是`\"BOOM\"`,找到这个字符串的地址，再找引用这个字符串的地址，再查找跳转到这个地址的指令，再看指令跳转的条件。这样就能找到校验密码的地方。\n\n```\n#字符串常量一半存储在.rodata段\n$cat bomb.txt | grep -n BOOM\n870: 4025a0 730a000a 424f4f4d 21212100 54686520  s...BOOM!!!.The\n```\n\n可以看出BOOM的地址在`0x4025a0`附近,查找引用这个地址的位置\n```\n$ cat bomb.txt | grep -n 4025a\n\n870: 4025a0 730a000a 424f4f4d 21212100 54686520  s...BOOM!!!.The \n2210:  40143e:    bf a3 25 40 00           mov    $0x4025a3,%edi\n2212:  401448:    bf ac 25 40 00           mov    $0x4025ac,%edi\n```\n```\n2208 000000000040143a <explode_bomb>:\n2209   40143a:   48 83 ec 08     sub    $0x8,%rsp\n2210   40143e:   bf a3 25 40 00  mov    $0x4025a3,%edi                    \n2211   401443:   e8 c8 f6 ff ff  callq  400b10 <puts@plt>\n2212   401448:   bf ac 25 40 00  mov    $0x4025ac,%edi\n2213   40144d:   e8 be f6 ff ff  callq  400b10 <puts@plt>\n2214   401452:   bf 08 00 00 00  mov    $0x8,%edi\n2215   401457:   e8 c4 f7 ff ff  callq  400c20 <exit@plt>\n```\n&ensp;&ensp;&ensp;&ensp;可以看到这里就是爆炸地方。然后再找引用`<explode_bomb>`的位置，就是校验密码的位置了。\n```\n$ cat bomb.txt | grep -n \"<explode_bomb>\"\n\n1765:  400ef2:    e8 43 05 00 00           callq  40143a <explode_bomb>\n1777:  400f10:    e8 25 05 00 00           callq  40143a <explode_bomb>\n1783:  400f20:    e8 15 05 00 00           callq  40143a <explode_bomb>\n1805:  400f65:    e8 d0 04 00 00           callq  40143a <explode_bomb>\n1824:  400fad:    e8 88 04 00 00           callq  40143a <explode_bomb>\n1830:  400fc4:    e8 71 04 00 00           callq  40143a <explode_bomb>\n1869:  401035:    e8 00 04 00 00           callq  40143a <explode_bomb>\n1878:  401058:    e8 dd 03 00 00           callq  40143a <explode_bomb>\n1893:  401084:    e8 b1 03 00 00           callq  40143a <explode_bomb>\n1910:  4010c6:    e8 6f 03 00 00           callq  40143a <explode_bomb>\n1941:  401123:    e8 12 03 00 00           callq  40143a <explode_bomb>\n1950:  401140:    e8 f5 02 00 00           callq  40143a <explode_bomb>\n2001:  4011e9:    e8 4c 02 00 00           callq  40143a <explode_bomb>\n2046:  401267:    e8 ce 01 00 00           callq  40143a <explode_bomb>\n2052:  40127d:    e8 b8 01 00 00           callq  40143a <explode_bomb>\n2208:000000000040143a <explode_bomb>:\n2232:  401494:    e8 a1 ff ff ff           callq  40143a <explode_bomb>\n2291:  401595:    e8 a0 fe ff ff           callq  40143a <explode_bomb>\n```\n首先看第一个引用的位置`1765行`\n```\n1759 0000000000400ee0 <phase_1>:\n1760   400ee0:   48 83 ec 08             sub    $0x8,%rsp\n1761   400ee4:   be 00 24 40 00          mov    $0x402400,%esi\n1762   400ee9:   e8 4a 04 00 00          callq  401338 <strings_not_equal>\n1763   400eee:   85 c0                   test   %eax,%eax\n1764   400ef0:   74 05                   je     400ef7 <phase_1+0x17>\n1765   400ef2:   e8 43 05 00 00          callq  40143a <explode_bomb>\n1766   400ef7:   48 83 c4 08             add    $0x8,%rsp\n1767   400efb:   c3                      retq\n\n```\n这里就是校验密码的位置。这里从函数名大概可以猜下是第一阶段，我们继续确认一下。查找引用`<phase_1>`的地方\n```\n$ cat bomb.txt | grep -n \"<phase_1>\"\n\n1714:  400e3a:    e8 a1 00 00 00           callq  400ee0 <phase_1>\n```\n查看`1714行`附近，就找到了程序的入口\n```\n1677 0000000000400da0 <main>:\n1678   400da0:   53                      push   %rbx\n...\n1710   400e28:   bf 78 23 40 00          mov    $0x402378,%edi\n1711   400e2d:   e8 de fc ff ff          callq  400b10 <puts@plt>\n1712   400e32:   e8 67 06 00 00          callq  40149e <read_line>\n1713   400e37:   48 89 c7                mov    %rax,%rdi\n1714   400e3a:   e8 a1 00 00 00          callq  400ee0 <phase_1>\n1715   400e3f:   e8 80 07 00 00          callq  4015c4 <phase_defused>\n1716   400e44:   bf a8 23 40 00          mov    $0x4023a8,%edi\n1717   400e49:   e8 c2 fc ff ff          callq  400b10 <puts@plt>\n1718   400e4e:   e8 4b 06 00 00          callq  40149e <read_line>\n1719   400e53:   48 89 c7                mov    %rax,%rdi\n1720   400e56:   e8 a1 00 00 00          callq  400efc <phase_2>\n\n```\n到这里，我们就可以确认`<phase_1>`就是我们要分析的地方。\n\n```\n1759 0000000000400ee0 <phase_1>:\n1760   400ee0:   48 83 ec 08             sub    $0x8,%rsp\n1761   400ee4:   be 00 24 40 00          mov    $0x402400,%esi\n```\n这里首先开栈，然后到0x402400寻址，字符串通常都是存放在.rodata段的，我们不妨看一下这个地址存的什么。\n```\n844  402400 426f7264 65722072 656c6174 696f6e73  Border relations\n845  402410 20776974 68204361 6e616461 20686176   with Canada hav\n846  402420 65206e65 76657220 6265656e 20626574  e never been bet\n847  402430 7465722e 00000000 576f7721 20596f75  ter.....Wow! You\n848  402440 27766520 64656675 73656420 74686520  've defused the\n849  402450 73656372 65742073 74616765 2100666c  secret stage!.fl\n850  402460 79657273 00000000 00000000 00000000  yers............\n```\n这里确实存了一组看起来是密码的字符串，到底是不是，调试一下就知道了。在`<phase_1>`处下断点，单步调试。\n```\n(gdb) disas\nDump of assembler code for function phase_1:\n    0x0000000000400ee0 <+0>:     sub    $0x8,%rsp\n    0x0000000000400ee4 <+4>:     mov    $0x402400,%esi\n=>  0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>\n    0x0000000000400eee <+14>:    test   %eax,%eax\n    0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>\n    0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>\n    0x0000000000400ef7 <+23>:    add    $0x8,%rsp\n    0x0000000000400efb <+27>:    retq   \nEnd of assembler dump.\n```\n查看%esi的值\n```\n(gdb) x/s $esi\n0x402400:    \"Border relations with Canada have never been better.\"\n```\n可以继续分析是哪几个寄存器在比较，但是这里我们可以试下，这个到底是不是我们找的密码呢。\n```\nPhase 1 defused. How about the next one?\n```\n果然就是我们要找的密码。\n\n### 4.phase_2\n\n现在来看下一个引用`<explode_bomb>`的地方，也就是`<phase_2>`\n```\n1769 0000000000400efc <phase_2>:\n1770   400efc:   55                      push   %rbp\n1771   400efd:   53                      push   %rbx\n1772   400efe:   48 83 ec 28             sub    $0x28,%rsp\n1773   400f02:   48 89 e6                mov    %rsp,%rsi\n1774   400f05:   e8 52 05 00 00          callq  40145c <read_six_numbers>\n1775   400f0a:   83 3c 24 01             cmpl   $0x1,(%rsp)  #栈顶 =1\n1776   400f0e:   74 20                   je     400f30 <phase_2+0x34>\n1777   400f10:   e8 25 05 00 00          callq  40143a <explode_bomb>\n1778   400f15:   eb 19                   jmp    400f30 <phase_2+0x34>\n1779   400f17:   8b 43 fc                mov    -0x4(%rbx),%eax\n1780   400f1a:   01 c0                   add    %eax,%eax\n1781   400f1c:   39 03                   cmp    %eax,(%rbx)\n1782   400f1e:   74 05                   je     400f25 <phase_2+0x29>\n1783   400f20:   e8 15 05 00 00          callq  40143a <explode_bomb>\n1784   400f25:   48 83 c3 04             add    $0x4,%rbx\n1785   400f29:   48 39 eb                cmp    %rbp,%rbx\n1786   400f2c:   75 e9                   jne    400f17 <phase_2+0x1b>\n1787   400f2e:   eb 0c                   jmp    400f3c <phase_2+0x40>\n1788   400f30:   48 8d 5c 24 04          lea    0x4(%rsp),%rbx\n1789   400f35:   48 8d 6c 24 18          lea    0x18(%rsp),%rbp\n1790   400f3a:   eb db                   jmp    400f17 <phase_2+0x1b>\n1791   400f3c:   48 83 c4 28             add    $0x28,%rsp\n1792   400f40:   5b                      pop    %rbx\n1793   400f41:   5d                      pop    %rbp\n1794   400f42:   c3                      retq\n```\n这里看起来输入了6个数字，进入`<read_six_numbers>`看一看\n```\n2217 000000000040145c <read_six_numbers>:\n2218   40145c:   48 83 ec 18             sub    $0x18,%rsp\n2219   401460:   48 89 f2                mov    %rsi,%rdx  # %rsi存放着phase_2的栈顶\n2220   401463:   48 8d 4e 04             lea    0x4(%rsi),%rcx\n2221   401467:   48 8d 46 14             lea    0x14(%rsi),%rax\n2222   40146b:   48 89 44 24 08          mov    %rax,0x8(%rsp)\n2223   401470:   48 8d 46 10             lea    0x10(%rsi),%rax\n2224   401474:   48 89 04 24             mov    %rax,(%rsp)\n2225   401478:   4c 8d 4e 0c             lea    0xc(%rsi),%r9\n2226   40147c:   4c 8d 46 08             lea    0x8(%rsi),%r8\n2227   401480:   be c3 25 40 00          mov    $0x4025c3,%esi  #格式化字符串\n2228   401485:   b8 00 00 00 00          mov    $0x0,%eax\n2229   40148a:   e8 61 f7 ff ff          callq  400bf0 <__isoc99_sscanf@plt>\n2230   40148f:   83 f8 05                cmp    $0x5,%eax\n2231   401492:   7f 05                   jg     401499 <read_six_numbers+0x3d>\n2232   401494:   e8 a1 ff ff ff          callq  40143a <explode_bomb>\n2233   401499:   48 83 c4 18             add    $0x18,%rsp\n2234   40149d:   c3                      retq\n```\n每次循环`rbx + 4` 等于`rsp + 0x18(24)`时退出，正好循环6次。\n```\n1779   400f17:   8b 43 fc                mov    -0x4(%rbx),%eax\n1780   400f1a:   01 c0                   add    %eax,%eax\n1781   400f1c:   39 03                   cmp    %eax,(%rbx)\n```\n从上面算出`*rbx = (*(rbx-4))*2`  这6个数就是个公比为2的等比数列，其中要求栈顶值为`1`。\n在`<read_six_numbers>`中，根据调用约定，得出phase_2栈顶用来存储第一个数字。所以答案为：\n```\n1 2 4 8 16 32\nThat's number 2.  Keep going!\n```\nBingo!!\n\n### 5.phase_3\n\n```\n1796 0000000000400f43 <phase_3>:\n1797   400f43:   48 83 ec 18             sub    $0x18,%rsp\n1798   400f47:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx #num2\n1799   400f4c:   48 8d 54 24 08          lea    0x8(%rsp),%rdx #num1\n1800   400f51:   be cf 25 40 00          mov    $0x4025cf,%esi\n1801   400f56:   b8 00 00 00 00          mov    $0x0,%eax\n1802   400f5b:   e8 90 fc ff ff          callq  400bf0 <__isoc99_sscanf@plt>\n1803   400f60:   83 f8 01                cmp    $0x1,%eax             #1.判断sscanf返回值>1\n1804   400f63:   7f 05                   jg     400f6a <phase_3+0x27> #2.跳转\n1805   400f65:   e8 d0 04 00 00          callq  40143a <explode_bomb>\n1806   400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)        #3.判断num1 < 7\n1807   400f6f:   77 3c                   ja     400fad <phase_3+0x6a>\n1808   400f71:   8b 44 24 08             mov    0x8(%rsp),%eax        #4.eax = num1\n1809   400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)    #5.switch case (num1)\n1810   400f7c:   b8 cf 00 00 00          mov    $0xcf,%eax            #6.\n1811   400f81:   eb 3b                   jmp    400fbe <phase_3+0x7b> \n1812   400f83:   b8 c3 02 00 00          mov    $0x2c3,%eax           #7.\n1813   400f88:   eb 34                   jmp    400fbe <phase_3+0x7b> \n1814   400f8a:   b8 00 01 00 00          mov    $0x100,%eax           #8.\n1815   400f8f:   eb 2d                   jmp    400fbe <phase_3+0x7b> \n1816   400f91:   b8 85 01 00 00          mov    $0x185,%eax           #9.\n1817   400f96:   eb 26                   jmp    400fbe <phase_3+0x7b> \n1818   400f98:   b8 ce 00 00 00          mov    $0xce,%eax            #10.\n1819   400f9d:   eb 1f                   jmp    400fbe <phase_3+0x7b> \n1820   400f9f:   b8 aa 02 00 00          mov    $0x2aa,%eax           #11.\n1821   400fa4:   eb 18                   jmp    400fbe <phase_3+0x7b> \n1822   400fa6:   b8 47 01 00 00          mov    $0x147,%eax           #12.\n1823   400fab:   eb 11                   jmp    400fbe <phase_3+0x7b> \n1824   400fad:   e8 88 04 00 00          callq  40143a <explode_bomb>\n1825   400fb2:   b8 00 00 00 00          mov    $0x0,%eax\n1826   400fb7:   eb 05                   jmp    400fbe <phase_3+0x7b>\n1827   400fb9:   b8 37 01 00 00          mov    $0x137,%eax\n1828   400fbe:   3b 44 24 0c             cmp    0xc(%rsp),%eax\n1829   400fc2:   74 05                   je     400fc9 <phase_3+0x86>\n1830   400fc4:   e8 71 04 00 00          callq  40143a <explode_bomb>\n1831   400fc9:   48 83 c4 18             add    $0x18,%rsp\n1832   400fcd:   c3                      retq\n```\n\n这里使用`sscanf`输入，就要传入格式化字符串，查看`0x400f56`内指向的值。\n```\n(gdb) x/s 0x4025cf\n0x4025cf:       \"%d %d\"\n```\n\n该阶段会输入两个数字。分别存在`%rdx,%rcx`指向的地址中。\n`1809   400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)`按指针来描述就是跳转到 *(0x0x402470+8*rax)，既然是跳转，所以`0x0x402470`里存的也是地址。实际上这里就是一个跳转表。disas可以看到地址的长度是8字节，是个64位程序。\n\n```\n(gdb) x/8xg 0x402470\n0x402470:       0x0000000000400f7c      0x0000000000400fb9\n0x402480:       0x0000000000400f83      0x0000000000400f8a\n0x402490:       0x0000000000400f91      0x0000000000400f98\n0x4024a0:       0x0000000000400f9f      0x0000000000400fa6\n```\n这里有8个跳转地址，与num1 取值[0,7]时一一对应，所以这里的答案有8种：（0，207）、（1，311）、（2，707）、（3，256）、（4，389）、（5，206）、（6，682）、（7，327）。\n\n### 6.phase_4\n```\n1858 000000000040100c <phase_4>:\n1859   40100c:   48 83 ec 18             sub    $0x18,%rsp\n1860   401010:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx\n1861   401015:   48 8d 54 24 08          lea    0x8(%rsp),%rdx\n1862   40101a:   be cf 25 40 00          mov    $0x4025cf,%esi\n1863   40101f:   b8 00 00 00 00          mov    $0x0,%eax\n1864   401024:   e8 c7 fb ff ff          callq  400bf0 <__isoc99_sscanf@plt>\n1865   401029:   83 f8 02                cmp    $0x2,%eax\n1866   40102c:   75 07                   jne    401035 <phase_4+0x29>\n1867   40102e:   83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp) # num1 < 14\n1868   401033:   76 05                   jbe    40103a <phase_4+0x2e>\n1869   401035:   e8 00 04 00 00          callq  40143a <explode_bomb>\n1870   40103a:   ba 0e 00 00 00          mov    $0xe,%edx\n1871   40103f:   be 00 00 00 00          mov    $0x0,%esi\n1872   401044:   8b 7c 24 08             mov    0x8(%rsp),%edi\n1873   401048:   e8 81 ff ff ff          callq  400fce <func4>\n1874   40104d:   85 c0                   test   %eax,%eax  #返回值为0\n1875   40104f:   75 07                   jne    401058 <phase_4+0x4c>\n1876   401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)  #num2 == 0\n1877   401056:   74 05                   je     40105d <phase_4+0x51>\n1878   401058:   e8 dd 03 00 00          callq  40143a <explode_bomb>\n1879   40105d:   48 83 c4 18             add    $0x18,%rsp\n1880   401061:   c3                      retq\n```\n这里输入参数时与上个阶段是一样的，输入两个数字`num1，num2`\n```\n(gdb) x/s 0x4025cf\n0x4025cf:       \"%d %d\"\n```\n\n初步分析可以得到`num1<14,num2=0`, 向`func4`传了3个参数,假设为`func4(int a,int b, int c)`，判断`func4(a,0,14)`的返回值为0时成功。\n进入`func4`可以发现是个递归函数。\n\n```\n1834 0000000000400fce <func4>:\n1835   400fce:   48 83 ec 08             sub    $0x8,%rsp\n1836   400fd2:   89 d0                   mov    %edx,%eax #第3个参数\n1837   400fd4:   29 f0                   sub    %esi,%eax #第2个参数\n1838   400fd6:   89 c1                   mov    %eax,%ecx\n1839   400fd8:   c1 e9 1f                shr    $0x1f,%ecx #ecx >>= 0x1f\n1840   400fdb:   01 c8                   add    %ecx,%eax\n1841   400fdd:   d1 f8                   sar    %eax #算术右移>>1\n1842   400fdf:   8d 0c 30                lea    (%rax,%rsi,1),%ecx #ecx = rax + 1*rsi\n1843   400fe2:   39 f9                   cmp    %edi,%ecx #第1个参数\n1844   400fe4:   7e 0c                   jle    400ff2 <func4+0x24>\n1845   400fe6:   8d 51 ff                lea    -0x1(%rcx),%edx\n1846   400fe9:   e8 e0 ff ff ff          callq  400fce <func4>\n1847   400fee:   01 c0                   add    %eax,%eax\n1848   400ff0:   eb 15                   jmp    401007 <func4+0x39>\n1849   400ff2:   b8 00 00 00 00          mov    $0x0,%eax\n1850   400ff7:   39 f9                   cmp    %edi,%ecx \n1851   400ff9:   7d 0c                   jge    401007 <func4+0x39>\n1852   400ffb:   8d 71 01                lea    0x1(%rcx),%esi\n1853   400ffe:   e8 cb ff ff ff          callq  400fce <func4>\n1854   401003:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax\n1855   401007:   48 83 c4 08             add    $0x8,%rsp\n1856   40100b:   c3                      retq\n```\n大概的c实现如下：\n```c\n//                %edi    %esi   %edx\nstatic int func4(int a, int b, int c)\n{\n    int tmp = (((c - b) + ((c - b) >> 31)) >> 1) + b;\n \n    if (tmp <= a) \n    {\n        if (tmp >= a)  //等于a时结束\n        {\n            return (0);\n        } \n        else \n        {\n            return func4(a, b + 1, c) * 2 + 1;\n        }\n    } \n    else \n    {\n        return func4(a, b, c - 1) * 2;\n    }\n}\n```\n这里根据`num1<14,num2=0`这个条件，遍历出所有的自然数答案`（0,0）、（1,0）、（3,0）、（7,0）`。\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, const char *argv[])\n{\n    int i, result;\n \n    for (i = 0; i < 14; ++i) \n    {\n        result = func4(i, 0, 14);\n        if (result == 0) \n        {\n            printf(\"%d\\n\", i);\n        }\n    }\n    return 0;\n}\n```\n\n### 7.phase_5\n\n待续。。。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["CSAPP","汇编"]},{"title":"obj","url":"/2019/04/01/obj/","content":"\n### 弱符号与强符号\n\n* 编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号\n>规则一：不允许强符号多次定义；如果有多个强符号，则链接器报符号重复定义错误。  \n>规则二：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。  \n>规则三：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。  \n* 尽量不要使用多个不用类型的弱符号，否则容易导致很难发现的程序错误。  \n\n### 弱引用和强引用\n\n* 强引用：链接器找不到该符号的定义，就用报符号未定义错误。\n\n* 弱引用：如果引用符号未被定义，链接器不报错。链接器默认未定义的弱引用为0或者一个特殊值，以便程序代码能够识别。\n\n```c\n//gcc不会报链接错误，但是会发生运行错误。因为foo函数的地址为0,会发生非法访问。\n__attribute__ ((weakref)) void foo();\nint main()\n{\n    foo();\n    return 0;\n}\n```\n\n```c\n//一个改进的例子。当foo没定义时不执行foo\n__attribute__ ((weakref)) void foo();\nint main()\n{\n    if(foo)\n        foo();\n    return 0;\n}\n```\n\n* 弱符号和弱引用对于库来说十分有用。  \n>如果一个程序被设计成可以支持单线程或者多线程的模式，就可以通过弱引用判断当前的程序是链接到了单线程Glibc库还是多线程的Glibc库。\n\n```c\n#include <stdio.h>\n#include <pthread.h>\nint pthread_create(\n    pthread_t*,\n    const pthread_attr_t*,\n    void* (*)(void*),\n    void*) __attribute__ ((weak));\n\nint main()\n{\n    if(pthread_create)\n        printf(\"This is multi-thread version!\\n\");\n    else    //当链接单线程的Glibc库时，pthread_create未定义，函数地址为0\n        printf(\"This is single-thread version!\\n\");\n    return 0;\n}\n```\n\n","tags":["链接"]},{"title":"Hello World","url":"/2019/03/31/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/senyee).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]